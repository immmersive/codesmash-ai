# Introduction

1. We need to create a problem-solving method.
2. This needs to be a general problem-solving method.
3. Once we have that, we can formalize it.
4. Then it’s easy to implement it on a computer.
5. We then set the system to continually learn and improve itself.
6. With this, we should get an AGI system.

# Step 1

The idea is that everything is treated as a problem, for which we need to provide a solution.
Thus, the process of problem-solving is that for a given problem, we need to present a solution.
We solve problems by thinking.
Thinking is the process of creating ideas that represent problems and solutions.
In order to submit ideas to a problem-solving process, we describe ideas using patterns.
Patterns allow us to distinguish between different ideas.
To describe something means to present it as a pattern.
The method then comes up with ideas, describes them with patterns, evaluates them, and presents the solution.

# Step 2

If it needs to be a general problem-solving method, it needs to be able to solve all problems.
Our method will need to take in all possible problems and output all possible solutions.
This means the method needs to take into account all possible patterns and present all possible patterns.
We use the principle of "use the right tool for the right job."
This means we are evaluating ideas with respect to the goal we want to achieve.
This is then a general optimization problem.
Furthermore, the pattern that leads us to the end goal is the optimal result, thus the correct solution.
Then, to start, we are presented with a problem, which is a starting state.
We are also presented with an end goal, which is the end state.
We are also presented with constraints with which we shall solve the problem.
We will then evaluate potential patterns with respect to the goal and constraints.
The optimal solution is then presented as the correct solution.
Since we have taken into account all possible patterns, we have a general problem-solving method.

# Step 3

We formalize the method M, which takes the following parameters of patterns:
    P defined as a problem.
    G defined as the goal.
    C defined as constraints.
    I defined as all available ideas.
We then select the idea which is optimal according to the classification.
The method returns a solution S, which is the optimal result with respect to the above parameters.

# Step 4

We now need to emulate this method on an actual computer.
We start with inputs and outputs and need to create an optimization problem.
The method needs to understand the parameters to evaluate their optimality.
We now enter a loop:
    We use pattern recognition and classify the patterns.
    We add all classifications to our ideas I.
    We evaluate how well each pattern works on each other pattern.
    When we have found the optimal solution, we store the result and return it.
    If there is no solution, we apply the method again.
The system needs to prime itself.
It needs to grow algorithms and data structures successfully with respect to its environment.
Only if it succeeds at lower steps can we expect it to move to higher steps.
Everything else is just pure memorization.
We can’t expect the system to learn on its own when left to its own devices.

# Basic Concepts

1. Use the right tool for the right job ✅
2. Ideas should be evaluated based on how useful they are with respect to the goal we are trying to achieve
3. Ideas
4. Patterns
5. The world as transformation of patterns
6. Descriptions
7. Computable Functions as Compressed Descriptions of Events
8. Abstraction models
9. Everything can be described as a problem solving exercise
10. Pragmatic appraoch
11. Pragmatism as problem solving framework
12. Problem solving as an optimization problem
13. Generalization and specialization
14. Information and search
15. Algorithms and data structures
16. The NFL theorem
17. Abstraction model hierarchy
18. Models as efficient data structures
19. Inference to the best explanation
20. Radical skepticism ✅
    
# Motivation

- To create a general problem solving framework

# Philosophical foundations

- Metanotions
- Pragmatism
- Ideas
- Problem-solving
- Limits of human reasoning

#  Implementations

- Computational system
- Definitions
